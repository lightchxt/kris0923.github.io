<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on 指北针</title><link>https://blog.ibird.site/tags/go/</link><description>Recent content in go on 指北针</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 23 Jul 2022 00:15:23 +0800</lastBuildDate><atom:link href="https://blog.ibird.site/tags/go/rss.xml" rel="self" type="application/rss+xml"/><item><title>GO语言类型转换</title><link>https://blog.ibird.site/post/golang/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link><pubDate>Sat, 23 Jul 2022 00:15:23 +0800</pubDate><guid>https://blog.ibird.site/post/golang/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid><description>基本数据类型 int 转string var i = 10 s := strconv.Itoa(i) fmt.Printf(&amp;#34;%v&amp;#34;, s) string 转int var s = &amp;#34;10&amp;#34; i, err := strconv.Atoi(s) if err != nil { fmt.Println(err) return } fmt.Printf(&amp;#34;%v&amp;#34;, i) // int64 ii, err := strconv.ParseInt(s, 10, 32) if err != nil { fmt.Println(err) return } fmt.Printf(&amp;#34;%v&amp;#34;, ii) // float64 f, err := strconv.ParseInt(s,</description></item><item><title>如何构建并发系统</title><link>https://blog.ibird.site/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</link><pubDate>Wed, 17 Jul 2019 23:10:51 +0000</pubDate><guid>https://blog.ibird.site/post/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</guid><description>本文简单说明几个设计并发系统时需要考虑的问题，内容摘抄自《GO语言并发之道》 异常传递 异常是什么，什么时候发生，提供了哪些好处 首先，异常需要传</description></item><item><title>GO语言语法基础</title><link>https://blog.ibird.site/post/go-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link><pubDate>Mon, 17 Dec 2018 00:15:23 +0800</pubDate><guid>https://blog.ibird.site/post/go-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid><description>基础语法 i++, i&amp;ndash; 在go语言中是语句，而不像其他语言一样是表达式，所以， j = i++ 在go语言里面是不合法的,并且只支持后缀， &amp;ndash;i 是不合法的 for 是go里面唯</description></item></channel></rss>